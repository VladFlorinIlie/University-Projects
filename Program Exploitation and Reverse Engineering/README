1. Descriere cod:
	Variabile globale folosite:
- ds:0x804a380 = in aceasta variabila este stocata adresa lui stdin (bss)
	- numele ar putea sa fie adr_stdin
- ds:0x804a3a0 = in aceasta variabila este stocata adresa lui stdout (bss)
	- numele ar putea sa fie adr_stdout
- ds:0x804a3a8 = contine adresa catre o zona de 1024 octeti alocata dinamic (bss)
	- numele poate sa fie din_buffer
- 0x804a240 = contine stringul: "|| Welcome to the vault ||\n|| Unlock it 
if you can ||" (data)
	- nume = welcome_str
- 0x804a2c0 = contine adresa catre stringul: "Choose an option:\n0. Solve the puzzle.\n1.
Enter your name.\n2. Enter your address.\n3. Enter key to unlock vault. 
(Broken keycheck)\n4. Send magic string (vault must be unlocked)\n5. Leave." (data)
	- nume = options_str
- 0x8048ca0 = contine adresa catre stringul: "Enter the valid serial: " care va fi folosit 
la puts in verif_serialkey (rodata)
	- nume = enter_serial
- 0x8048cb9 = contine adresa catre: "%32s" folosit la scanf in option0 (rodata)
	- nume = serial_scanf
- 0x8048cbe = contine adresa catre: "Correct!" afisat in option0 (rodata)
	- nume = correct_serial
- 0x8048cc7 = "Nope, try again." afisat tot in option0 (rodata)
	- nume = wrong_serial
- 0x8048cd8 = "Enter desired username: " afisat in option1 (rodata)
	- nume = enter_name
- 0x8048cf1 = "%20s" folosit de scanf in option1 si option2 (rodata)
	- nume = address_name_scanf
- 0x8048cf6 = "Enter desired address: " afisat in option2 (rodata)
	- nume = enter_address
- ds:0x804a210 = initial contine 1, este modificata de functia gate1 si folosita in option4 (data)
	- nume = var_gate1
- ds:0x804a214 = initial contine 1, este modificata de functia gate2 si folosita in option4 (data)
	- nume = var_gate2
- ds:0x804a218 = initial contine 1, este modificata de functia gate3 si folosita in option4 (data)
	- nume = var_gate3
- 0x8048d0e = "Vault is still locked." afisata in option4 (rodata)
	- nume = locked_vault
- 0x804a200 = "Vlad" folosita de strstr in option4 (data)
	- nume = prenume
- 0x804a205 = "Ilie" folosita de strstr in oprion4 (data)
	- nume = nume
- variabilele: ds:0x804a220, ds:0x804a224, ds:0x804a228, ds:0x804a22c, ds:0x804a230,
ds:0x804a234 contin bucati de cod criptate cu xor 0xaa care vor fi mutate in din_buffer
de catre functiile gate1, gate2, gate3 si vor fi folosite in option4. (data)
- 0x8048d3a = "Bye." afisata de choose_option la iesire (rodata)
	- nume = exit_str
- 0x8048d3f = "Unknown option." afisata de choose_option in cazul unei optiuni mai mari
ca 5 (rodata)
	- nume = wrong_option
- 0x8048d36 = "%1d" folosit de scanf in choose_option (rodata)
	- nume = option_scanf
- ds:0x804a21c = contine intregul 1 si este folosita in verify_win pe post de conditie pentru
win (data)
	- nume = verif_win
- 0x8048d25 = "Win!" afisata in verify_win in cazul in care conditiile sunt indeplinite (rodata)
	- nume = win
- 0x8048d2a = "Try harder!" afisata in verify_win in caz de esec (rodata)
	- nume = try_again
- 0x804a20a = "321CB" nu este folosita (adresa luata din data dump) (data)


	0x8048871 = void print_welcome()
	Aceasta functie nu are parametri si este de tipul void. Apeleaza functia puts
careia ii transmite welcome_str ca parametru.

	0x8048883 = void print_options()
	Apeleaza functia puts cu parametrul options_str.


	0x8048635 = void decrypt_xor(char *str, int nr_elem)
	Functia aloca pe stiva doua variabile: char caracter, int i.
	La inceput verifica daca variabila i (contorul) a ajuns la numarul maxim
de caractere. In cazul in care nu a ajuns, muta caracterul de la pozitia curenta 
din str in variabila caracter, face xor cu 0xaa si muta caracterul decodificat 
inapoi in stringul primit ca parametru apoi creste contorul cu 1.
	Cod C:

	int i = 0;
	char caracter;
	while(i < nr_elem) {
		caracter = str[i];
		caracter ^= 0xaa;
		str[i] = caracter;
		i++;
	}


	0x8048a20 = void curata_reg()
	Aceasta functie seteaza valoarea 0 pe registrele: ah, ecx, edx si esi.


	0x8048a52 = int verifica_egalitate()
	Functia foloseste ZF pentru a verifica daca cele doua elemente comparate
inaine de apelul acestei functii sunt egale sau nu. In cazul in care nu sunt egale,
eax devine 0 si functia returneaza 0. Altfel returneaza 1.


	0x8048a29 = int ascii2hex()
	In primul rand, functia verifica daca registrul dl contine o cifra sau o
litera intre a-f (in codul ascii). Daca da, in cazul in care e cifra scade 0x30
pentru a trece din ascii in hex. Daca e litera, scade 0x57. In cazul in care nu
e cifra nici litera intre a-f, eax devine 0 deci functia returneaza 0. Functia
nu primeste parametri pe stiva ci se foloseste de registrul dl.
	Cod C:

	if(carac >= 0x30) {
		if(carac <= 0x39)
			carac -= 0x30;
		else if(carac >= 0x61) {
			if(carac <= 0x66)
				carac -= 0x57;
			else
				return 0;
		}
		else
			return 0;
	}
	else
		return 0;

	Cam asa ar arata codul tradus direct din assembly in C.


	0x8048a5d = int verif_serialkey(char *serial_key)
	Functia verifica daca primele 13 caractere din serial_key trec de anumite
conditii si daca suma celor 13 caractere este egala cu 0x390. Aceasta functie foloseste
functiile curata_reg, verifica_egalitatea si ascii2hex care mai mult par sa fie bucati
din aceasta functie decat functii individuale deoarece nu respecta conventia de apel cdecl
folosita de C. Toate egalitatile sunt verificate de functia verifica_egalitatea.
	La inceput, eax este 1 (in codul de mai jos am folosit variabila ok). In cazul in 
care una din conditii nu este respectata, eax devine 0.
	Cod C:
	
	ok = 1;
	if((serial_key[0] << 4) ^ f0 != 0x90)
		ok = 0;
	if((serial_key[0] >> 4) ^ f != 0x9)
		ok = 0;
	if(serial_key[1] + serial_key[3] != 0x94)
		ok = 0;
	if(serial_key[2] + serial_key[3] != 0x67)
		ok = 0;
	if(serial_key[1] + serial_key[2] != 0x97)
		ok = 0;
	if((serial_key[4] << 4) ^ f0 != c0)
		ok = 0;
	if((serial_key[4] >> 4) ^ f != 9)
		ok = 0;
	if(serial_key[5] + serial_key[7] != 0x69)
		ok = 0;
	if(serial_key[6] + serial_key[7] != 0x99)
		ok = 0;
	if(serial_key[5] + serial_key[6] != 0x94)
		ok = 0;
	if((serial_key[8] << 4) ^ f0 != f0)
		ok = 0;
	if((serial_key[8) >> 4) ^ f != c)
		ok = 0;
	apeleaza ascii2hex pentru serial_key[9] si serial_key[10]
	if(serial_key[9] + serial_key[10] != 0x13)
		ok = 0;
	if(serial_key[10] != 0xc)
		ok = 0;
	apeleaza ascii2hex pentru serial_key[11] si serial_key[12]
	if(serial_key[11] + serial_key[12] != 0x9)
		ok = 0;
	if(serial_key[12] != 0x0)
		ok = 0;
	for(i = 0; i < 13; i++)
		suma = serial_key[i];
	if(suma != 0x390)
		ok = 0;
	return ok;

	Caracterele modificate atunci cand este apelata functia ascii2hex, nu sunt 
scrise peste caracterele originale din serial_key ci sunt stocate in registre. Dar,
pentru simplitate, in codul de mai sus am folosit tot vectorul serial_key si pentru
acestea. 
	Interpretarea codului:
	byte 1: 0x!6
	byte 1: 0x6!	deci byte1: 0x66
	
	byte2 + byte4 = 0x94
	byte3 + byte4 = 0x67
	byte2 + byte3 = 0x97

	byte5: 0x!3
	byte5: 0x6!	deci byte5: 0x63

	byte6 + byte8 = 0x69
	byte7 + byte8 = 0x99
	byte6 + byte7 = 0x94

	byte9: 0x!0
	byte9: 0x3!	deci byte9: 0x30

	verifica daca byte10 e cifra sau a-f si scade 0x30 sau 0x57 din acesta
	verifica daca byte11 e cifra sau a-f si scade 0x30 sau 0x57 din acesta
	byte10 + byte11 = 0x13
	byte11 = 0xc

	verifica daca byte12 e cifra sau a-f si scade 0x30 sau 0x57 din acesta
	verifica daca byte13 e cifra sau a-f si scade 0x30 sau 0x57 din acesta
	byte12 + byte13 = 0x9
	byte13 = 0x0

	suma celor 13 octeti = 0x390 (la suma se folosesc ultimii 4 octeti din stringul
original, nu cei modificati de ascii2hex).


	0x8048679 = void option0()
	Functia aloca un vector de 32 caractere pe care il umple cu zerouri. Afiseaza
apoi veriabila enter_serial cu ajutorul lui puts iar dupa aceea citeste cu scanf 32 de 
caractere in vectorul alocat anterior. Apeleaza functia verif_serialkey care primeste
ca parametru vectorul de 32 de caractere. La final, verifica rezultatul functiei
verif_serialkey. In cazul in care a returnat 1, afiseaza variabila correct_serial altfel
afiseaza variabila wrong_serial.


	0x80486ea = void option1()
	Functia aloca un vector de 20 caractere, afiseaza variabila enter_name apoi
citeste 20 de caractere in vectorul de mai sus.


	0x8048710 = void option2()
	Functia aloca un vector de 16 caractere, afiseaza variabila enter_address apoi
citeste 20 de caractere in vectorul alocat anterior.


	0x8048736 = void option3()
	Functia aloca un vector de 4 caractere pe stiva apoi citeste cu ajutorul functiei 
read 24 de caractere la adresa variabilei alocate anterior.

	
	0x80485eb = int sum_chars(char *str)
	Sunt alocate doua variabile (pentru suma si contor) apoi face suma primelor 
1024 caractere din str si verifica daca este egala cu 74565.
	Cod C:

	int suma = 0, i = 0;
	while(i < 1023) {
		suma += str[i];
		i++
	}
	if(suma == 74565)
		return 1;
	return 0;


	0x804874e = void option4()
	Este alocat un vector de 1028 de octeti. Apoi se verifica daca cele trei variabile:
var_gate1, var_gate2, var_gate3 sunt egale cu 0 altfel este afisata variabila locked_vault.
Dupa aceea, sunt citite 1024 de caractere de la tastatura la finalul carora va fi pus
caracterul null. Este apelata functia decrypt_xor(din_buffer, 1024) apoi este apelata
functia sum_chars ce primeste ca parametru vectorul alocat anterior. Daca functia returneaza
0, functia option4 este oprita. In continuare, sunt cautate stringurile continute de
variabilele nume si prenume in vectorul citit de la tastatura iar daca nu sunt gasite,
functia option4 se opreste. La final, zone de memorie a carei adresa este stocata in
variabila din_buffer primeste permisiunile read si execute setate cu ajutorul functiei
mprotect si este apelat codul aflat in aceasta zona de memorie.
	Cod C:

	char v[1028];
	if(var_gate1 != 0) {
		puts(locked_vault);
		return;
	}
	if(var_gate2 != 0) {
		puts(locked_vault);
		return;
	}
	if(var_gate3 != 0) {
		puts(locked_vault);
		return;
	}
	read(0, v + 3, 1024);
	v[1027] = 0;
	decrypt_xor(din_buffer, 1024);
	if(sum_chars(v + 3) == 0)
		return;
	if(!strstr(v + 3, prenume))
		return;
	if(!strstr(v + 3, nume))
		return;
	mprotect(din_buffer, 1024, 5);
	apeleaza functia de la adresa din_buffer


	0x8048895 = void gate1()
	Seteaza variabila var_gate1 la 0 apoi pune doua double word-uri pe primele 8 
pozitii din din_buffer.


	0x80488ba = void gate2(int var)
	Verifica daca var este egala cu 0xdeadc0de. Daca da, seteaza variabila var_gate2
la 0 apoi muta pe urmatoarele 8 pozitii alte 2 double word-uri (bucati de cod criptate).


	0x80488ea = void gate3(int var1, int var2)
	Aloca doua int-uri pe stiva, in prima variabila pune suma celor doi parametri iar
in a doua pune diferenta lor. Suma trebuie sa fie egala cu 0xdeadbeef iar diferenta egala
cu 0x13371337 deci var1 = 0x78f26913, var2 = 0x65bb55dc. Daca trece de aceasta verificare,
variabila var_gate3 devine 0 si sunt copiate alte doua double word-uri pe urmatoarele
8 pozitii.


	ds:0x804a3a8 - functia aflata in zona de memorie spre care indica ds:0x804a3a8
	void copy(char *str)
	Functia aloca un vector de 1000 de caractere pe stiva apoi copiaza 1024 de caractere
de la adresa str la vectorul alocat anterior.
	Aceasta functie va fi apelata de catre option4.


	0x804882b = void verify_win()
	Functia aloca un int pe stiva la care copiaza primii 4 octeti din din_buffer.
Variabila este shiftata apoi cu 16 la stanga si este facut xor cu valoarea originala apoi
este inmultita cu 0x45d9f3a. Daca rezultatul este egal cu valoarea din verif_win atunci
este afisata variabila win altfel este afisata try_again.
	Cod C:
	
	int nr;
	nr = *((int *) din_buffer);
	nr = nr << 16;
	nr = nr ^ *((int *) din_buffer);
	if(nr * 0x45d9f3a == verif_win)
		puts("Win!");
	else
		puts("Try harder!");


	0x804893a = void choose_option()
	Aloca un int pe stiva, apoi citeste de la tastatura numarul optiunii. Functia
foloseste un switch pentru a apela optiunea dorita. In cazul in care numarul optiunii
este mai mare ca 5, este afisata variabila wrong_option. Daca este aleasa optiunea 5
(iesirea) este afisata variabila exit_str si este apelta functia exit.
	Cod C:

	int option;
	scanf("%1d", &option);
	switch(option) {
	case 0: option0(); break;
	case 1: option1(); break;
	case 2: option2(); break;
	case 3: option3(); break;
	case 4: option4(); break;
	case 5: puts("Bye."); exit(1);
	default: puts("Unknown option.");
	}


	
	0x80489a9 = main
	Functia main apeleaza setbuf de 0 si adr_stdin/adr_stdout pentru a crea un output
si un input non-buffered. Dupa aceea, aloca 1024 octeti de memorie dinamica si copiaza
adresa acestei zone de memorie in variabila din_buffer. Decodifica welcome_str si
options_str prin intermediul functiei decrypt_xor apoi apeleaza in continuu functiile
print_welcome, print_options si choose_option.
	Cod C:

	setbuf(stdin, NULL);
	setbuf(stdout, NULL);
	din_buffer = mmap(NULL, 1024, 3, 34, -1, 0);
	decrypt_xor(welcome_str, 105);
	decrypt_xor(options_str, 185);
	while(1 == 1) {
		print_welcome();
		print_options();
		choose_option();
	}


2. Vulnerabilitati si bug-uri:
	Exista buffer overflow in urmatoarele functii:
	1) option0 - este alocat un buffer de 32 octeti si sunt citite de la tastatura
32 de caractere. Scanf adauga la finalul stringului caracterul null deci pentru un buffer
de 32 de caractere va fi folosit spatiu pentru 33 de caractere si avand in vedere ca
bufferul se aloca imediat dupa vechiul ebp, cel mai nesemnificativ octet al vechiului ebp
va fi suprascris cu 0. (Bug)
	2) option1 - este alocat un buffer de 20 octeti imediat dupa vechiul ebp si sunt
citite cu scanf 20 de caractere. Se intampla acelasi lucru ca la optiunea0. (Bug)
	3) option2 - este alocat un buffer de 16 octeti imediat dupa vechiul ebp si sunt
citite cu scanf 20 de caractere. In acest caz, vechiul ebp este suprascris complet 
iar cel mai nesemnificativ octet din adresa de return este inlocuit cu 0. (Bug)
	4) option3 - sunt alocati 4 octeti imediat dupa vechiul ebp si sunt citite cu
cu read 24 de caractere. In acest caz, vechiul ebp si adresa de return pot fi inlocuite
cu orice isi doreste utilizatorul prin intermediul unui payload. (Vulnerabilitate)
	5) copy (functia aflata in zona de memorie indicata de din_buffer) - se aloca
un buffer de 1000 de octeti imediat dupa vechiul ebp si sunt mutati 1024 de octeti,
din stringul primit, in bufferul alocat anterior. In acest fel, pot fi suprascrise vechiul
ebp si adresa de return. (Vulnerabilitate)


3. Exploatare:
	Payload-ul are 4 parti:
	1) Pentru inceput, este apelata optiunea 3 si este citita prima parte a payload-ului.
Prima parte suprascrie adresa de return cu adresa functiei gate1 si imediat dupa
aceasta (pe post de adresa de return pentru gate1) este adresa lui option3. Astfel
variabila var_gate1 devine 0 si se copiaza in din_buffer prima parte din codul functiei
copy.
	2) La intoarcerea in functia option3, este citita urmatoarea parte din payload
care suprascrie adresa de return cu adresa functiei gate2, dupa aceasta vine adresa
functiei option3 si in final, parametrul de care are nevoie functia gate2: 0xdeadc0de.
	3) La a doua intoarcere, adresa de return este suprascrisa cu adresa
functiei gate3, in continuare este adresa lui option4 si cei doi parametrii ai functiei
gate3.
	4) In optiunea 4, dupa ce sunt verificate cele 3 variabile setate de functiile gate,
este citita ultima parte a payload-ului. Aceasta contine numele Vlad si Ilie care sunt
verificate de catre cele doua strstr. Inainte de nume, se afla un shellcode ce modifica
variabila verif_win astfel:
		mov    eax,ds:0x804a3a8
		mov    ebx,eax
		shl    eax,0x10
		xor    eax,ebx
		imul   eax,eax,0x45d9f3a
		mov    ds:0x804a21c,eax
		push   exit
		push   0x804882b
		ret
	Acest shellcode urmeaza pasii facuti de functia verify_win iar la final seteaza
variabila verif_win cu valoarea corecta. Pune pe stiva adresa functiei verify_win (care
va fi folosita de ret) si ca adresa de return pentru verify_win este functia exit.
	Payload-ul (pe langa toate caracterele de umplutura) contine si adresa la care
se va afla shellcode-ul, iar aceasta adresa va fi scrisa peste adresa de return a functiei
copy. Restul octetilor au fost alesi astfel incat suma lor sa fie egala cu 74565. Acesta
ultima parte a payload-ului contine si caracterul '\n' la inceput ramas de la payload-ul
anterior.
	
